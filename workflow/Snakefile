#tell us how you did#
onsuccess:
    print("Workflow finished, no error")

onerror:
    print("An error occurred")

#pulls names from seqs in upload folder, assigns list as a variable#
SEQS = glob_wildcards("upload/{seq}.fna").seq

#rules run by default#
rule all:
    input: 
        "results.tar.gz"

#check there are files in upload folder that output directories exist#
rule check_folders:
    input:
        expand("upload/{seq}.fna", seq=SEQS)
    output:
        directory("results"),
        # directory("results/ccfinder"),
        directory("results/cctyper"),
        directory("results/cidentify"),
        # directory("results/cdetect"),
        directory("results/padloc"),
        # directory("results/benchmark"),
    log:
        out="logs/folders_prancc.log",
        err="logs/folders_prancc.error.log",
    shell:'''
        mkdir -pv {output} >> {log.out} 2>> {log.err}
        '''

# edit all '/' characters in sequence names to '_' to prevent cidentify errors
# edit all '@' characters in sequence names to '_' to prevent cctyper errors
# rename upload directory to clean
rule check_inputs:
    input:
        seq = expand("upload/{seq}.fna", seq=SEQS),
        dir = "results",
    output:
        expand("clean/{seq}.fna", seq=SEQS)
    log:
        out="logs/inputs_prancc.log",
        err="logs/inputs_prancc.error.log",
    shell:'''
        mv -v upload/*.fna clean >> {log.out} 2>> {log.err}
        '''
        #         sed -i 's/[/,@]/_/g' {input.seq} 
        # grep -Hn '/' {input.seq} >> {log.out} 2>> {log.err}
        # grep -l '/' {input.seq} >> {output} 2>> {log.err}

# run cctyper and output results to directory in results/cctyper named after .fasta
rule cctyper:
    input:
        "clean/{seq}.fna"
    output:
        directory("results/cctyper/{seq}")
    benchmark:
        "results/benchmark/cct_{seq}.txt"
    log:
        out="logs/cctyper_{seq}.log",
        err="logs/cctyper_{seq}.error.log",
    threads: 1
    conda:
        "envs/cctyper.yaml"
    shell:'''
        cctyper --threads {threads} \
            {input}.fna {output} >> {log.out} 2>> {log.err}
        '''

# run ccfinder, output results to directory in results/ccfinder named after .fasta input
# to avoid bug in ccfinder, I specify a directory in cwd, then later move it
# seriously if you're reading this and scoffing, just do it. don't try to do it in /tmp/ 
# or send it directly to results. that really is the bug. any path that isn't a folder
# that doesn't exist in cwd = error.
rule ccfinder:
    input:
        "clean/{seq}.fna"
    output:
        directory("results/ccfinder/{seq}")
    benchmark:
        "results/benchmark/ccf_{seq}.txt"
    log:
        out="logs/ccfinder_{seq}.log",
        err="logs/ccfinder_{seq}.error.log",
    threads: 1
    conda:
        "envs/ccfinder.yaml"
    shell:'''
        perl bin/ccfinder/CRISPRCasFinder.pl -so bin/ccfinder/sel392v2.so -in {input} -out {wildcards.seq} -cas -cpuM {threads} >> {log.out} 2>> {log.err}
        mv {wildcards.seq} {output}
        '''
# run cidentify, output results to directory in results/cidentify named after .fasta input
rule cidentify:
    input:
        "clean/{seq}.fna"
    output:
        "results/cidentify/{seq}/Complete_Cas_summary.csv",
        "results/cidentify/{seq}/Complete_Cassette_summary.csv",
        "results/cidentify/{seq}/Complete_array_dataset.fasta",
        "results/cidentify/{seq}/Complete_repeat_dataset.fasta",
        "results/cidentify/{seq}/Complete_spacer_dataset.fasta",
        "results/cidentify/{seq}/Complete_summary.csv",
        dir = directory("results/cidentify/{seq}"),
    benchmark:
        "results/benchmark/ci_{seq}.txt"
    log:
        out="logs/cidentify_{seq}.log",
        err="logs/cidentify_{seq}.error.log",
    threads: 1
    conda:
        "envs/cidentify.yaml"
    shell:'''
        python bin/cidentify/CRISPRidentify.py \
        --file {input} \
        --result_folder {output.dir} \
        --cas "True" > {log.out} 2>> {log.err}
        touch {output}
        '''

# run cdetect, output results to 3 files in a directory named after input fasta in 
# results/cdetect. For use in detecting CRISPR-Cas genes with PADLOC
rule cdetect:
    input:
         "clean/{seq}.fna"
    output:
        "results/cdetect/{seq}/{seq}.1_crispr.gff",
        "results/cdetect/{seq}/{seq}.1_crispr.fp",
        dir = directory("results/cdetect/{seq}"),
        file = "results/cdetect/{seq}/{seq}.1_crispr",
    benchmark:
        "results/benchmark/cd_{seq}.txt"
    log:
        out="logs/cdetect_{seq}.log",
        err="logs/cdetect_{seq}.error.log",
    threads: 1
    conda:
        "padloc"
    shell:'''
        run-crisprdetect --input {input} --output {output.file} >> {log.out} 2>> {log.err}
        '''

# run padloc with output from crisprdetect, output results to directory in results/padloc 
# named after input fasta.
rule padloc:
    input:
        seq = "clean/{seq}.fna",
        file = "results/cdetect/{seq}/{seq}.1_crispr.gff",
    output:
        directory("results/padloc/{seq}")
    benchmark:
        "results/benchmark/padloc_{seq}.txt"
    log:
        out="logs/padloc_{seq}.log",
        err="logs/padloc_{seq}.error.log",
    threads: 1
    conda:
        "padloc"
    shell:'''
        mkdir {output}
        padloc --fna {input.seq} \
        --crispr {input.file} \
        --outdir {output} \
        --cpu {threads} >> {log.out} 2>> {log.err}
        '''

#collate results per result step#
rule collate_cct:
    input:
        expand("results/cctyper/{seq}", seq=SEQS)
    output:
        "results/cctyper.tsv"
    threads: 1
    shell: "./comparison/scripts/collatecct.sh results/cctyper/ {output}"

rule collateccf:
    input:
        expand("results/ccfinder/{seq}", seq=SEQS)
    output:
        "results/ccfcas.tsv",
        "results/ccfcrispr.tsv",
    threads: 1
    shell: "./comparison/scripts/collateccf.sh results/ccfinder/ {output}"

rule collatecidentify:
    input:
        expand("results/cidentify/{seq}", seq=SEQS),
    output:
        "results/cidentify.tsv",
        "results/cidentify_cas.tsv",
    threads: 1
    shell: "./comparison/scripts/collateci.sh {input} results/cidentify {output}"

rule collatepadloc:
    input:
        expand("results/padloc/{seq}", seq=SEQS)
    output:
        "results/padloc.tsv"
    threads: 1
    shell: "./comparison/scripts/collatepadloc.sh results/padloc/ {output}"

#gets the versions of each program run#
rule get_ccfinder_version:
    output:
        "results/ccfver.log"
    conda:
        "envs/ccfinder.yaml"
    shell:'''
        echo -e "\n -- CRISPRCasFinder environment --\n" > {output}
        conda list >> {output}
        '''

rule get_cctyper_version:
    output:
        "results/cctver.log"
    conda:
        "envs/cctyper.yaml"
    shell:'''
        echo -e "\n -- CRISPRCasTyper environment --\n" > {output}
        conda list >> {output}
        '''

rule get_cidentify_version:
    output:
        "results/civer.log"
    conda:
        "envs/cidentify.yaml"
    shell:'''
        echo -e "\n -- CRISPRIdentify environment --\n" > {output}
        conda list >> {output}
        '''

rule get_versions:
    input:
        ccf = "results/ccfver.log",
        cct = "results/cctver.log",
        ci = "results/civer.log",
    output:
        "results/version.log"
    shell:'''
        echo "PRANCc version 0.3.0-beta" > {output}
        conda --version >> {output}
        echo -e "\n -- PADLOC environment --\n" 
        conda list -n padloc >> {output}
        echo -e "\n -- CRISPRDetect environment --\n" 
        conda list -n crisprdetect >> {output}
        echo -e "\n -- snakemake environment --\n" 
        conda list -n snakemake >> {output}
    '''
            # cat {input} {output} >> {output}

rule cat_benchmarks:
    input:
        cct = expand("results/benchmark/cct_{seq}.txt", seq=SEQS),
        ccf = expand("results/benchmark/ccf_{seq}.txt", seq=SEQS),
        ci = expand("results/benchmark/ci_{seq}.txt", seq=SEQS),
        cd = expand("results/benchmark/cd_{seq}.txt", seq=SEQS),
        padloc = expand("results/benchmark/padloc_{seq}.txt", seq=SEQS),
    output:
        cct = "results/benchmark/cct.txt",
        ccf = "results/benchmark/ccf.txt",
        ci = "results/benchmark/ci.txt",
        cd = "results/benchmark/cd.txt",
        padloc = "results/benchmark/padloc.txt",
    shell:'''
        touch {output}
        '''
        #         sed -n '1p' {input.cct}[0] > {output.cct}
        # sed '1d' {input.cct} >> {output.cct}

        # sed -n '1p' {input.ccf}[0] > {output.ccf}
        # sed '1d' {input.ccf} >> {output.ccf}

        # sed -n '1p' {input.ci}[0] > {output.ci}
        # sed '1d' {input.ci} >> {output.ci}

        # sed -n '1p' {input.cd}[0] > {output.cd}
        # sed '1d' {input.cd} >> {output.cd}

        # sed -n '1p' {input.padloc}[0] > {output.padloc}
        # sed '1d' {input.padloc} >> {output.padloc}

rule cat_logs:
    input:
        cct = expand("logs/cctyper_{seq}.log", seq=SEQS),
        ccterror = expand("logs/cctyper_{seq}.error.log", seq=SEQS),
        ccf = expand("logs/ccfinder_{seq}.log", seq=SEQS),
        ccferror = expand("logs/ccfinder_{seq}.error.log", seq=SEQS),
        ci = expand("logs/cidentify_{seq}.log", seq=SEQS),
        cierror = expand("logs/cidentify_{seq}.error.log", seq=SEQS),
        cd = expand("logs/cdetect_{seq}.log", seq=SEQS),
        cderror = expand("logs/cdetect_{seq}.error.log", seq=SEQS),
        padloc = expand("logs/padloc_{seq}.log", seq=SEQS),
        padlocerror = expand("logs/padloc_{seq}.error.log", seq=SEQS),
        folders_prancc = "logs/folders_prancc.log",
        folders_pranccerror = "logs/folders_prancc.error.log",
        input_prancc = "logs/inputs_prancc.log",
        input_pranccerror = "logs/inputs_prancc.error.log",
    output:
        cct = "logs/cct.log",
        ccterror = "logs/cct.error.log",
        ccf = "logs/ccf.log",
        ccferror = "logs/ccf.error.log",
        ci = "logs/ci.log",
        cierror = "logs/ci.error.log",
        cd = "logs/cd.log",
        cderror = "logs/cd.error.log",
        padloc = "logs/padloc.log",
        padlocerror = "logs/padloc.error.log",
        prancc = "logs/prancc.log",
        pranccerror = "logs/prancc.error.log",
    shell:'''
        cat {input.cct} >> {output.cct}
        cat {input.ccterror} >> {output.ccterror}

        cat {input.ccf} >> {output.ccf}
        cat {input.ccferror} >> {output.ccferror}

        cat {input.ci} >> {output.ci}
        cat {input.cierror} >> {output.cierror}

        cat {input.cd} >> {output.cd}
        cat {input.cderror} >> {output.cderror}

        cat {input.padloc} >> {output.padloc}
        cat {input.padlocerror} >> {output.padlocerror}

        cat {input.folders_prancc} {input.input_prancc} >> {output.prancc}
        cat {input.folders_pranccerror} {input.input_pranccerror} >> {output.pranccerror}
        '''

#compile into tarball#
rule create_tarball:
    input:
        expand("results/cctyper/{seq}", seq=SEQS),
        expand("results/ccfinder/{seq}", seq=SEQS),
        expand("results/cidentify/{seq}", seq=SEQS),
        expand("results/cidentify/{seq}/Complete_Cas_summary.csv", seq=SEQS),
        expand("results/cidentify/{seq}/Complete_Cassette_summary.csv", seq=SEQS),
        expand("results/cidentify/{seq}/Complete_array_dataset.fasta", seq=SEQS),
        expand("results/cidentify/{seq}/Complete_repeat_dataset.fasta", seq=SEQS),
        expand("results/cidentify/{seq}/Complete_spacer_dataset.fasta", seq=SEQS),
        expand("results/cidentify/{seq}/Complete_summary.csv", seq=SEQS),
        expand("results/cdetect/{seq}/{seq}.1_crispr", seq=SEQS),
        expand("results/cdetect/{seq}/{seq}.1_crispr.gff", seq=SEQS),
        expand("results/cdetect/{seq}/{seq}.1_crispr.fp", seq=SEQS),
        expand("results/padloc/{seq}", seq=SEQS),
        "results/ccfcas.tsv",
        "results/ccfcrispr.tsv",
        "results/cctyper.tsv",
        "results/cidentify.tsv",
        "results/cidentify_cas.tsv",
        "results/padloc.tsv",
        "results/version.log",
        "results/benchmark/ccf.txt",
        "results/benchmark/cct.txt",
        "results/benchmark/ci.txt",
        "results/benchmark/cd.txt",
        "results/benchmark/padloc.txt",
        "logs/prancc.log",
        "logs/prancc.error.log",
        "logs/cct.log",
        "logs/cct.error.log",
        "logs/ccf.log",
        "logs/ccf.error.log",
        "logs/ci.log",
        "logs/ci.error.log",
        "logs/cd.log",
        "logs/cd.error.log",
        "logs/padloc.log",
        "logs/padloc.error.log",
    output:
        "results.tar.gz"
    shell:'''
        tar -czf {output} {input}
        mkdir -p upload
        mv clean/* upload
        rm -r clean
        '''
