import os

#tell us how you did#
onsuccess:
    print("Workflow finished, no error")

onerror:
    print("An error occurred")

#pulls names from seqs in upload folder, assigns list as a variable#
SEQS = glob_wildcards("upload/{seq}.fna").seq

#rules run by default#
rule all:
    input: 
        "results.tar.gz"

#check there are files in upload folder; that output directories exist#
rule check_folders:
    input:
        expand("upload/{seq}.fna", seq=SEQS)
    output:
        directory("results"),
        directory("results/cctyper"),
        directory("results/cidentify"),
        # directory("results/cdetect"),
        directory("results/padloc"),
    shell: "mkdir -p {output}"

#create list based on seqs in upload directory#
rule list_inputs:
    input:
        expand("upload/{seq}.fna", seq=SEQS)
    output:
        "input_list.txt"
    shell: "echo {input} | tr ' ' '\n' > {output}"

#run cctypper; generate results#
rule cctyper:
    input: 
        a="input_list.txt",
        b="results",
    output:
        directory(expand("results/cctyper/{seq}/", seq=SEQS))
    threads: 2
    conda:
        "envs/cctyper.yaml"
    shell:'''
        while read file
        do
            filename=$(basename $file .fna)
            cctyper --threads {threads} $file results/cctyper/$filename
        done < {input.a}
        '''

#run ccfinder; generate results#
rule ccfinder:
    input:
        a="input_list.txt",
        b="results",
    output:
        directory("results/ccfinder/")
    threads: 1
    conda:
        "crisprcasfinder"
    shell:'''
        mkdir -p results/ccfinder
        cd results/ccfinder
        while read file
        do
            filename=$(basename $file .fna)
            perl ../../bin/ccfinder/CRISPRCasFinder.pl --so ../../bin/ccfinder/sel392v2.so --in ../../$file
        done < ../../{input.a}
        cd ../..
        '''

#run cidentify; generate results#
rule cidentify:
    input:
        a="input_list.txt",
        b="results",
    output:
        directory(expand("results/cidentify/{seq}/", seq=SEQS))
    threads: 2
    conda:
        "crispr_identify_env"
    shell:'''
        mkdir -p {output}
    '''
    # python bin/cidentify/CRISPRidentify.py --cpu {threads} --input_folder upload --result_folder {output}

#run cdetect; generate results -->.gff used for padloc to run#
rule cdetect:
    input:
        a="input_list.txt",
        b="results",
    output:
        expand("results/cdetect/{seq}.1_crispr", seq=SEQS),
        expand("results/cdetect/{seq}.1_crispr.gff", seq=SEQS),
        expand("results/cdetect/{seq}.1_crispr.fp", seq=SEQS),
    threads: 2
    conda:
        "padloc"
    shell:'''
        while read file
        do
            filename=$(basename $file .fna)
            run-crisprdetect --input $file --output results/cdetect/$filename.1_crispr
        done < {input.a}
        '''
        # run-crisprdetect --input $file --output results/cdetect/$filename.1_crispr

#run padloc; generate results#
rule padloc:
    input:
        a="input_list.txt",
        b="results",
        c=expand("results/cdetect/{seq}.1_crispr.gff", seq=SEQS),
    output:
        directory(expand("results/padloc/{seq}/", seq=SEQS))
    threads: 2
    conda:
        "padloc"
    shell:'''
        while read file
        do
            filename=$(basename $file .fna)
            mkdir -p results/padloc/$filename
            padloc --fna $file --crispr results/cdetect/$filename.1_crispr.gff --outdir results/padloc/$filename --cpu {threads}
        done < {input.a}
        '''

#collate results per result step#
rule collate_cct:
    input:
        expand("results/cctyper/{seq}/", seq=SEQS)
    output:
        "results/cctyper.tsv"
    shell: "comparison/scripts/collatecct.sh results/cctyper/ {output}"

rule collateccf:
    input:
        "results/ccfinder/"
    output:
        "results/ccfinder.tsv"
    threads: 1
    shell: "comparison/scripts/collateccf.sh results/ccfinder/ {output}"

rule collatecidentify:
    input:
        expand("results/cidentify/{seq}/", seq=SEQS)
    output:
        "results/cidentify.tsv"
    shell: "comparison/scripts/collateci.sh results/cidentify/ {output}"

rule collatepadloc:
    input:
        expand("results/padloc/{seq}/", seq=SEQS)
    output:
        "results/padloc.tsv"
    shell: "comparison/scripts/collatepadloc.sh results/padloc/ {output}"

#gets the versions of each program run#
rule get_versions:
    output:
        log = "versions.tsv"
    shell:

#compile into tarball#
rule create_tarball:
    input:
        "results/cctyper.tsv",
        expand("results/cctyper/{seq}/", seq=SEQS),
        "results/ccfinder.tsv",
        "results/ccfinder/",
        "results/cidentify.tsv",
        expand("results/cidentify/{seq}/", seq=SEQS),
        expand("results/cdetect/{seq}.1_crispr", seq=SEQS),
        expand("results/cdetect/{seq}.1_crispr.gff", seq=SEQS),
        expand("results/cdetect/{seq}.1_crispr.fp", seq=SEQS),
        "results/padloc.tsv",
        expand("results/padloc/{seq}/", seq=SEQS),
    output:
        "results.tar.gz"
    shell:"tar -czvf {output} {input}"
